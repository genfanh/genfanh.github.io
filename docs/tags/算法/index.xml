<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on genfanh Blog</title>
    <link>https://genfanh.github.io/tags/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on genfanh Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 05 Nov 2020 17:51:36 +0800</lastBuildDate><atom:link href="https://genfanh.github.io/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>72.编辑距离</title>
      <link>https://genfanh.github.io/p/edit-distance/</link>
      <pubDate>Thu, 05 Nov 2020 17:51:36 +0800</pubDate>
      
      <guid>https://genfanh.github.io/p/edit-distance/</guid>
      <description>一、题目 题目
二、解法 动态规划 dp[i][j]代表 word1 的前 i 个字符转换成 word2 的前 j 字符需要的最少操作数
所以，
当 word1[i] == word2[j] 时， dp[i][j] = dp[i-1][j-1]
当 word1[i] != word2[j] 时， dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
其中，dp[i-1][j-1] 表示替换操作， dp[i-1][j] 表示删除操作， dp[i][j-1] 表示插入操作。
注意，针对第一行和第一列需要淡入考虑，如下图所示，引入 &#39;&#39;:

第一行，是 word1 为空时变为 word2 最少要走的步数，也就是插入操作
第一列，是 word2 为空时 word1 变为 word2 最少要走的步数， 也是删除操作
最终结果就是 dp[i][j]
复杂度 时间复杂度： O(m*n)
空间复杂度： O(m*n)
三、代码 func minDistance(word1 string, word2 string) int { n, m := len(word1), len(word2) dp := make([][]int, n+1) // word2 为空时 word1 变为 word2 最少要走的步数  for i:=0; i&amp;lt;=n; i++ { dp[i] = make([]int, m+1) dp[i][0] = i } // word1 为空时变为 word2 最少要走的步数  for j:=0; j&amp;lt;=m; j++ { dp[0][j] = j } for i:=1; i&amp;lt;=n; i++ { for j:=1; j&amp;lt;=m;j++ { if word1[i-1] == word2[j-1] { dp[i][j] = dp[i-1][j-1] } else { dp[i][j] = 1 + min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) } } } return dp[n][m] } func min(x, y int) int { if x &amp;lt; y { return x } return y } </description>
    </item>
    
    <item>
      <title>322.零钱兑换</title>
      <link>https://genfanh.github.io/p/coin-change/</link>
      <pubDate>Thu, 05 Nov 2020 17:10:50 +0800</pubDate>
      
      <guid>https://genfanh.github.io/p/coin-change/</guid>
      <description>一、题目 题目
二、解法 动态规划 构造动态方程时，我们认为
 dp[i]为凑成i金额所需要的最少硬币的数值  所以，当所有coins面值硬币选择一个时，其凑成的dp[i-coins[j]]的数值是最小时，可以认为dp[i]最小，动态转化表达式可以有
dp[i] = min( dp[i-coins[j]] ) + 1 此时最终题解为，
 ans = dp[amount]  复杂度 时间复杂度：O(amount * len(coins) )
空间复杂度：O(amount)
三、代码 func coinChange(coins []int, amount int) int { if amount == 0 { return 0 } dp := make([]int, amount+1) // 初始化所有 i&amp;gt;0 的 dp[i] 为 -1  for i := range dp { if i != 0 { dp[i] = -1 } } n := len(coins) for i:=1; i&amp;lt;=amount; i++ { minVal := math.</description>
    </item>
    
    <item>
      <title>188.买卖股票的最佳时机</title>
      <link>https://genfanh.github.io/p/sell-stock/</link>
      <pubDate>Wed, 04 Nov 2020 20:30:57 +0800</pubDate>
      
      <guid>https://genfanh.github.io/p/sell-stock/</guid>
      <description>一、题目 题目
二、解法 动态规划 状态流转图
交易k次的状态流转图如上图所示。
初始状态时，手中没有股票，在初始状态可以保持该动作，不买不卖直至交易结束。
初始状态只能通过买入进入到买入1状态，当买入1股后，我们可以有以下两种选择：
 啥也不做，保持买入1股状态，直至若干天后择优卖出 马上手上股票，进入卖出1状态  在卖出1状态时，也有两种选择：
 啥也不做，保持手上没有股票动作，直至下一个好时机买入 马上进行第二次买入，进入买入2状态  后面的买入2，保持，卖出2直至卖出k后，就无法在进行交易，只能进入交易结束状态
所以在构造动态规划方程时，使用三个状态变量来表示买卖k次的交易状态
 i表示第i天 k表示已经进行了k次买卖 j表示当前手上是否持有股票  此时我们得到动态规划状态表达式dp[i][k][j]，其中
 dp[i][k][0]表示第i天交易了k次后手上不持有股票的累计最大利润 dp[i][k][1]表示第i天交易了k次后手上持有股票的累计最大利润  此时，我们通过状态转化图，可以有
# 第i天交易k次后手上不持有股票的累计最大利润为， 1、第i-1天k次后手上不持有股票的累计最大利润，或 2、第i-1天k次交易后手上持有股票的累计最大利润加上第i天卖出股票 ； 1或2中的最大值 dp[i][k][0] = max( dp[i-1][k][0], d[i-1][k][1] + prices[i] ) # 第i天交易k次后手上持有股票的累计最大利润为， 1、第i-1天k次后手上持有股票的累计最大利润，或 2、第i-1天k-1次交易后手上不持有股票的累计最大利润减去第i天买入股票 ； 1或2中的最大值 dp[i][k][1] = max( dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) # 此时题目解为 第i天 0~k 次交易后，手上不持有股票的累计利润最大值 answer = max(dp[i][0~k][0]) 三、代码 func maxProfit(k int, prices []int) int { pLen := len(prices) if len(prices) == 0{ return 0 } //一次交易需要2天，如果交易次数大于总的天数/2，那么可以认为k是无穷大，套框架  if k &amp;gt; pLen/2{ return maxProfit_k_Inf(prices) } tmp := make([][2]int, k+1) dp := make([][][2]int, 0) for i:=0; i&amp;lt;pLen;i++{ dp = append(dp, tmp) } for i:=0; i&amp;lt;pLen; i++{ //base case  if i == 0 { for d:=0; d&amp;lt;=k; d++{ dp[i][d][0]=0 dp[i][d][1]=-prices[i] } continue } for j:=k; j&amp;gt;=1; j--{ dp[i][j][0]=max(dp[i-1][j][0], dp[i-1][j][1]+prices[i]) dp[i][j][1]=max(dp[i-1][j][1], dp[i-1][j-1][0]-prices[i]) } } return dp[pLen-1][k][0] } func maxProfit_k_Inf(prices []int) int { if len(prices) == 0 { return 0 } dp := make([][2]int, len(prices)) /* k = +infinity dp[i][k][0]=max(dp[i-1][k][0], dp[i-1][k][1]+prices[i]) dp[i][k][1]=max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i]) =max(dp[i-1][k][1], dp[i-1][k][0]-prices[i]) 我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) */ for i:=0; i&amp;lt;len(prices); i++{ if i-1 == -1{ dp[i][0]=0 dp[i][1]=-prices[i] continue } dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) } return dp[len(prices)-1][0] } func max(x, y int) int{ if x &amp;gt; y{ return x } return y } </description>
    </item>
    
  </channel>
</rss>
