<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>client-go on genfanh Blog</title>
    <link>https://genfanh.github.io/tags/client-go/</link>
    <description>Recent content in client-go on genfanh Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 06 Feb 2021 17:53:39 +0800</lastBuildDate><atom:link href="https://genfanh.github.io/tags/client-go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>client-go EventBroadcaster事件管理器简介</title>
      <link>https://genfanh.github.io/p/client-go-eventbroadcaster/</link>
      <pubDate>Sat, 06 Feb 2021 17:53:39 +0800</pubDate>
      
      <guid>https://genfanh.github.io/p/client-go-eventbroadcaster/</guid>
      <description>1. 概述 k8s的事件（Event）是一种资源对象（Resource Object），用于记录集群内发生的情况，kubernetes各个组件会把运行时发生的各种事件上报给api-server，如调度器做了什么决定等。默认情况下只会显示最近（一小时内）发生的事件。 由于k8s事件是一种资源对象，因此事件都会被存储在etcd中，而为了避免磁盘空间被填满，所以回强制执行保留策略：在最后一次的事件发生后，删除1小时之前发生的事件。 因为k8s系统中Pod资源是最核心的资源，如Deployment、StatefulSet、ReplicaSet、DaemonSet、Job、CronJob等最终都会创建出Pod。所以k8s事件也是围绕Pod进行的，在Pod的生命周期内的关键步骤中都会产生事件消息。Event资源数据结构体定义在core资源组下，具体代码示例如下：
代码路径：vendor/k8s.io/api/core/v1/types.go
type Event struct { metav1.TypeMeta metav1.ObjectMeta InvolvedObject ObjectReference Reason string Message string Source EventSource FirstTimestamp metav1.Time LastTimestamp metav1.Time Count int32 Type string EventTime metav1.MicroTime Series *EventSeries Action string Related *ObjectReference ReportingController string ReportingInstance string } Event资源数据结构体描述了当前时间段内发生了哪些关键性事件。事件有两种类型：Normal（正常事件）和Warning（警告事件）。代码示例如下：
const ( // Information only and will not cause any problems 	EventTypeNormal string = &amp;#34;Normal&amp;#34; // These events are to warn that something might go wrong 	EventTypeWarning string = &amp;#34;Warning&amp;#34; ) 2.</description>
    </item>
    
    <item>
      <title>client-go Informer简介</title>
      <link>https://genfanh.github.io/p/client-go-informer/</link>
      <pubDate>Wed, 03 Feb 2021 20:38:01 +0800</pubDate>
      
      <guid>https://genfanh.github.io/p/client-go-informer/</guid>
      <description>1. 概述 k8s其他组件如kubelet、controller manager、scheduler都是通过client-go的Informer机制与api-server进行通信。所以在阅读组件源代码时，需要先理解client-go的informer机制。
2. Informer架构 图1 Infomer架构
如图所示，Informer的中核心组件有Reflector、DeltaFIFO以及Indexer。下面对各个组件进行重点介绍：
2.1. Reflector Reflector主要用作监控(Watch)Informer创建时指定的k8s资源（可以是内置资源或者CRD资源），当监控的资源发生变化时会触发相应的事件，如Added事件、Updated事件、Deleted事件（分别对应资源对象的添加、更新以及删除），并将该事件对应的资源对象存放到本地缓存DeltaFIFO中。 Reflector对象主要通过NewReflector函数进行实例化，查看函数入参可以知道，在Reflector对象实例化的时候需要传入一个ListerWatcher数据接口对象，该对象拥有List和Watch方法，用于获取和监控资源列表。Reflector对象通过Run函数驱动监控并处理监控事件，在Run函数中可以看到，Reflector主要重复运行ListAndWatch函数获取资源列表(List)并监控(Watch)资源。
代码路径：client-go/tools/cache/reflector.go
func NewReflector(lw ListerWatcher, expectedType interface{}, store Store, resyncPeriod time.Duration) *Reflector { return NewNamedReflector(naming.GetNameFromCallsite(internalPackages...), lw, expectedType, store, resyncPeriod) } // Run repeatedly uses the reflector&amp;#39;s ListAndWatch to fetch all the // objects and subsequent deltas. // Run will exit when stopCh is closed. func (r *Reflector) Run(stopCh &amp;lt;-chan struct{}) { ... wait.BackoffUntil(func() { if err := r.</description>
    </item>
    
  </channel>
</rss>
