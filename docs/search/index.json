[{"content":"一、题目   题目 \n二、解法 动态规划   \n  初始化 dp=[false, ⋯ , false]，长度为 n+1。n 为字符串长度。dp[i] 表示 s 的前 i 位是否可以用 wordDict 中的单词表示。\n  初始化 dp[0]=true，空字符可以被表示。\n  遍历字符串的所有子串，遍历开始索引 i，遍历区间 [0,n)：\n 遍历结束索引 j，遍历区间 [i+1,n+1)：  若 dp[i]=true且 s[i, ⋯ ,j) 在 wordlist 中：dp[j]=true。解释：dp[i]=true 说明 s 的前 i 位可以用 wordDict 表示，则 s[i, ⋯ ,j) 出现在 wordDict 中，说明 s 的前 j 位可以表示。      返回 dp[n]\n  复杂度分析  时间复杂度：O(n^2^) 空间复杂度：O(n)  三、代码 func wordBreak(s string, wordDict []string) bool { size := len(s) m := make(map[string]bool, len(wordDict)) for _, word := range wordDict { m[word] = true } dp := make([]bool, size+1) dp[0] = true for i:=0; i\u0026lt;size; i++ { for j:=i+1; j\u0026lt;=size; j++ { if dp[i] \u0026amp;\u0026amp; m[s[i:j]] { dp[j] = true } } } return dp[size] } 四、参考 转载自：动态规划+记忆化回溯 逐行解释 python3 - 单词拆分 - 力扣（LeetCode） (leetcode-cn.com)\n","date":"2020-11-07T16:03:54+08:00","permalink":"https://genfanh.github.io/p/words-split/","title":"139.单词拆分"},{"content":"一、题目   题目 \n二、解法 动态规划+回溯  动态规划得到了原始输入字符串的任意长度的 前缀子串 是否可以拆分为单词集合中的单词； 我们以示例 2：s = \u0026quot;pineapplepenapple\u0026quot;、wordDict = [\u0026quot;apple\u0026quot;, \u0026quot;pen\u0026quot;, \u0026quot;applepen\u0026quot;, \u0026quot;pine\u0026quot;, \u0026quot;pineapple\u0026quot;] 为例，分析如何得到所有具体解。  所有任意长度的前缀是否可拆分是知道的，那么如果 后缀子串在单词集合中，这个后缀子串就是解的一部分，例如：\n  示例 \n再对比这个问题的输出：\n[ \u0026quot;pine apple pen apple\u0026quot;, \u0026quot;pineapple pen apple\u0026quot;, \u0026quot;pine applepen apple\u0026quot; ] 可以发现，树形结构中，从叶子结点到根结点的路径是符合要求的一个解，与以前做过的回溯算法的问题不一样，这个时候路径变量我们需要在依次在列表的开始位置插入元素，可以使用队列实现。\n三、代码 func wordBreak(s string, wordDict []string) bool { ans := make([]string, 0) size := len(s) // 使用 map 加速查找 \twordMap := make(map[string]bool, size + 1) for _, word := range wordDict { wordMap[word] = true } // 查找是否有解 \tdp := make([]bool, size+1) dp[0] = true for i:=0; i\u0026lt;size; i++ { for j:=i+1; j\u0026lt;=size; j++ { if dp[i] \u0026amp;\u0026amp; wordMap[s[i:j]] { dp[j] = true } } } // 回溯算法，获取所有解 \tpath := make([]string, 0) var backtracking func(start int) backtracking = func(start int) { if start == size \u0026amp;\u0026amp; dp[size] { tmp := strings.Join(path, \u0026#34; \u0026#34;) ans = append(ans, tmp) return } for i := start+1; i\u0026lt;=size; i++ { if dp[start] \u0026amp;\u0026amp; wordMap[s[start:i]] { path = append(path, s[start:i]) backtracking(i) path = path[:len(path)-1] } } } if dp[size] { backtracking(0) } return ans } 四、参考 转载自：动态规划求是否有解、回溯算法求所有具体解（Java） - 单词拆分 II - 力扣（LeetCode） (leetcode-cn.com)\n","date":"2020-11-07T16:03:54+08:00","permalink":"https://genfanh.github.io/p/words-split-ii/","title":"140.单词拆分II"},{"content":"一、题目   题目 \n二、解法 回溯+动态规划优化 搜索问题主要使用回溯法。\n回溯法思考的步骤：\n1、画递归树；\n2、根据自己画的递归树编码。\n思考如何根据这棵递归树编码：\n1、每一个结点表示剩余没有扫描到的字符串，产生分支是截取了剩余字符串的前缀；\n2、产生前缀字符串的时候，判断前缀字符串是否是回文。\n如果前缀字符串是回文，则可以产生分支和结点； 如果前缀字符串不是回文，则不产生分支和结点，这一步是剪枝操作。 3、在叶子结点是空字符串的时候结算，此时从根结点到叶子结点的路径，就是结果集里的一个结果，使用深度优先遍历，记录下所有可能的结果。\n 采用一个路径变量 path 搜索，path 全局使用一个（注意结算的时候，需要生成一个拷贝），因此在递归执行方法结束以后需要回溯，即将递归之前添加进来的元素拿出去； path 的操作只在列表的末端，因此合适的数据结构是栈。  利用「力扣」第 5 题：最长回文子串 的思路，使用空间换时间，利用动态规划把结果先算出来，这样就可以以 O(1) 的时间复杂度直接得到一个子串是否是回文。\n三、代码 func partition(s string) [][]string { ans := make([][]string,0) size := len(s) if size == 0 { return ans } // 预处理 \t// 使用 dp[i][j] 表示 s[i:j] 是否回文 \tdp := make([][]bool, size) for i := range dp { dp[i] = make([]bool, size) } for r:=0; r\u0026lt;size; r++ { for l:=0; l\u0026lt;=r; l++ { if s[l] == s[r] \u0026amp;\u0026amp; (r - l \u0026lt;=2 || dp[l+1][r-1]) { dp[l][r] = true } } } path := make([]string, 0) var backtracking func(start int) backtracking = func (start int) { if start \u0026gt;= size { tmp := make([]string, len(path)) copy(tmp, path) ans = append(ans, tmp) return } for i := start; i \u0026lt; size; i++ { if !dp[start][i] { continue } path = append(path, s[start:i+1]) backtracking(i+1) path = path[:len(path)-1] } } backtracking(0) return ans } 四、参考 转载自：回溯、优化（使用动态规划预处理数组） - 分割回文串 - 力扣（LeetCode） (leetcode-cn.com)\n","date":"2020-11-07T15:15:03+08:00","permalink":"https://genfanh.github.io/p/split-palindrome-string/","title":"131.分割回文串"},{"content":"一、题目   题目 \n二、解法 动态规划 dp[i][j]代表 word1 的前 i 个字符转换成 word2 的前 j 字符需要的最少操作数\n所以，\n当 word1[i] == word2[j] 时， dp[i][j] = dp[i-1][j-1]\n当 word1[i] != word2[j] 时， dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n其中，dp[i-1][j-1] 表示替换操作， dp[i-1][j] 表示删除操作， dp[i][j-1] 表示插入操作。\n注意，针对第一行和第一列需要淡入考虑，如下图所示，引入 '':\n  \n第一行，是 word1 为空时变为 word2 最少要走的步数，也就是插入操作\n第一列，是 word2 为空时 word1 变为 word2 最少要走的步数， 也是删除操作\n最终结果就是 dp[i][j]\n复杂度 时间复杂度： O(m*n)\n空间复杂度： O(m*n)\n三、代码 func minDistance(word1 string, word2 string) int { n, m := len(word1), len(word2) dp := make([][]int, n+1) // word2 为空时 word1 变为 word2 最少要走的步数  for i:=0; i\u0026lt;=n; i++ { dp[i] = make([]int, m+1) dp[i][0] = i } // word1 为空时变为 word2 最少要走的步数  for j:=0; j\u0026lt;=m; j++ { dp[0][j] = j } for i:=1; i\u0026lt;=n; i++ { for j:=1; j\u0026lt;=m;j++ { if word1[i-1] == word2[j-1] { dp[i][j] = dp[i-1][j-1] } else { dp[i][j] = 1 + min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) } } } return dp[n][m] } func min(x, y int) int { if x \u0026lt; y { return x } return y } ","date":"2020-11-05T17:51:36+08:00","permalink":"https://genfanh.github.io/p/edit-distance/","title":"72.编辑距离"},{"content":"一、题目   题目 \n二、解法 动态规划 构造动态方程时，我们认为\n dp[i]为凑成i金额所需要的最少硬币的数值  所以，当所有coins面值硬币选择一个时，其凑成的dp[i-coins[j]]的数值是最小时，可以认为dp[i]最小，动态转化表达式可以有\ndp[i] = min( dp[i-coins[j]] ) + 1 此时最终题解为，\n ans = dp[amount]  复杂度 时间复杂度：O(amount * len(coins) )\n空间复杂度：O(amount)\n三、代码 func coinChange(coins []int, amount int) int { if amount == 0 { return 0 } dp := make([]int, amount+1) // 初始化所有 i\u0026gt;0 的 dp[i] 为 -1  for i := range dp { if i != 0 { dp[i] = -1 } } n := len(coins) for i:=1; i\u0026lt;=amount; i++ { minVal := math.MaxInt64 for j:=0; j\u0026lt;n; j++ { // 若 dp[i-coins[j]] = -1 认为 dp[i-coins[j]] 无解  if i - coins[j] \u0026gt;= 0 \u0026amp;\u0026amp; dp[i-coins[j]] != -1 { minVal = min(minVal, dp[i-coins[j]]) } } // 若minVal没有被赋值， 则认为 dp[i] 无解  if minVal != math.MaxInt64 { dp[i] = minVal + 1 } } return dp[amount] } func min(x, y int) int { if x \u0026lt; y { return x } return y } ","date":"2020-11-05T17:10:50+08:00","permalink":"https://genfanh.github.io/p/coin-change/","title":"322.零钱兑换"},{"content":"一、题目   题目 \n二、解法 动态规划   状态流转图 \n交易k次的状态流转图如上图所示。\n初始状态时，手中没有股票，在初始状态可以保持该动作，不买不卖直至交易结束。\n初始状态只能通过买入进入到买入1状态，当买入1股后，我们可以有以下两种选择：\n 啥也不做，保持买入1股状态，直至若干天后择优卖出 马上手上股票，进入卖出1状态  在卖出1状态时，也有两种选择：\n 啥也不做，保持手上没有股票动作，直至下一个好时机买入 马上进行第二次买入，进入买入2状态  后面的买入2，保持，卖出2直至卖出k后，就无法在进行交易，只能进入交易结束状态\n所以在构造动态规划方程时，使用三个状态变量来表示买卖k次的交易状态\n i表示第i天 k表示已经进行了k次买卖 j表示当前手上是否持有股票  此时我们得到动态规划状态表达式dp[i][k][j]，其中\n dp[i][k][0]表示第i天交易了k次后手上不持有股票的累计最大利润 dp[i][k][1]表示第i天交易了k次后手上持有股票的累计最大利润  此时，我们通过状态转化图，可以有\n# 第i天交易k次后手上不持有股票的累计最大利润为， 1、第i-1天k次后手上不持有股票的累计最大利润，或 2、第i-1天k次交易后手上持有股票的累计最大利润加上第i天卖出股票 ； 1或2中的最大值 dp[i][k][0] = max( dp[i-1][k][0], d[i-1][k][1] + prices[i] ) # 第i天交易k次后手上持有股票的累计最大利润为， 1、第i-1天k次后手上持有股票的累计最大利润，或 2、第i-1天k-1次交易后手上不持有股票的累计最大利润减去第i天买入股票 ； 1或2中的最大值 dp[i][k][1] = max( dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) # 此时题目解为 第i天 0~k 次交易后，手上不持有股票的累计利润最大值 answer = max(dp[i][0~k][0]) 三、代码 func maxProfit(k int, prices []int) int { pLen := len(prices) if len(prices) == 0{ return 0 } //一次交易需要2天，如果交易次数大于总的天数/2，那么可以认为k是无穷大，套框架  if k \u0026gt; pLen/2{ return maxProfit_k_Inf(prices) } tmp := make([][2]int, k+1) dp := make([][][2]int, 0) for i:=0; i\u0026lt;pLen;i++{ dp = append(dp, tmp) } for i:=0; i\u0026lt;pLen; i++{ //base case  if i == 0 { for d:=0; d\u0026lt;=k; d++{ dp[i][d][0]=0 dp[i][d][1]=-prices[i] } continue } for j:=k; j\u0026gt;=1; j--{ dp[i][j][0]=max(dp[i-1][j][0], dp[i-1][j][1]+prices[i]) dp[i][j][1]=max(dp[i-1][j][1], dp[i-1][j-1][0]-prices[i]) } } return dp[pLen-1][k][0] } func maxProfit_k_Inf(prices []int) int { if len(prices) == 0 { return 0 } dp := make([][2]int, len(prices)) /* k = +infinity dp[i][k][0]=max(dp[i-1][k][0], dp[i-1][k][1]+prices[i]) dp[i][k][1]=max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i]) =max(dp[i-1][k][1], dp[i-1][k][0]-prices[i]) 我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) */ for i:=0; i\u0026lt;len(prices); i++{ if i-1 == -1{ dp[i][0]=0 dp[i][1]=-prices[i] continue } dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) } return dp[len(prices)-1][0] } func max(x, y int) int{ if x \u0026gt; y{ return x } return y } ","date":"2020-11-04T20:30:57+08:00","permalink":"https://genfanh.github.io/p/sell-stock/","title":"188.买卖股票的最佳时机"},{"content":"今天主要记录用hugo搭建个人博客的过程，避免下次搭建流程遗失。\n一、安装Hugo 本人使用的是Windows系统，所以选择scoop安装方式。具体步骤如下：\n1、安装scoop 参考 github scoop 网站安装\n2、使用scoop安装hugo 安装hugo拓展版本，因为后续选择主题需要拓展版本，所以安装了此版本\nscoop install hugo-extended 若不喜欢使用拓展版本，可以使用以下指令安装基础版本\nscoop install hugo 3、验证hugo安装 打开CMD，输入hugo version，若版本正确输出则安装成功\n其他平台可参考官网安装教程 Install Hugo\n二、使用hugo创建博客 1、创建网站 在创建前，请进入工作目录\n# 执行创建指令 # 其中 blog 是网站名称，即会在工作目录下创建blog名称文件夹 # 所有网站文件都在blog目录下 hugo new site blog 2、添加hugo主题 hugo有很多第三方开源的主题，可以在官网的themes下自行选择。本人选Stack主题作为博客的主题。\n主题选好后进入blog（也就是刚才创建网站是创建出来的目录）目录下，把stack主题git到themes目录下。\ncd blog git init git submodule add https://github.com/CaiJimmy/hugo-theme-stack.git  注：记得提前安装git\n 3、修改config.toml配置文件 正常流程应该直接修改config.toml文件，但是Stack主题已经内置修改好的文件，直接复制该config.toml到根目录即可\necho 'theme = \u0026quot;hugo-theme-stack\u0026quot;' \u0026gt;\u0026gt; config.toml 4、创建第一篇文章 hugo new posts/HelloWorld.md 5、启动hugo服务器 hugo server -D 三、把Hugo部署到Github Pages上 1、创建一个Github仓库 在github上创建一个仓库，名称一般为\u0026lt;gihub名称\u0026gt;.github.io\n  git_create_repo \n2、把仓库clone到本地 git clone \u0026lt;REPO_URL\u0026gt; 3、创建hugo项目 参照第二步，在仓库目录下创建一个Hugo项目，同时保证hugo项目能在本地运行\nhugo server -D 4、创建新文章 hugo new post/HelloWorld.md 通过指令创建的markdown文章会自动生成如下模板头：\n--- title: \u0026#34;HelloWorld\u0026#34; date: 2020-10-30T21:52:31+08:00 draft: true ---  注：需要把 draft: true 改为 draft: false 才可以上传该篇文章\n 5、修改repo配置 进入刚刚创建的 Repository 的 Setting 界面， 把 GitHub Page 配置下的 Source 配置为Branch:master/docs。这意味着通过URL访问博客时，会从该仓库 master 分支下的 docs 文件夹下读取静态资源。具体如下图所示：\n  repo_settings \n6、修改 config.toml 从第5点得到 GitHub Page 的 URL，把该 URL 替换到 config.toml 配置文件的 baseURL 配置值中\nbaseURL = \u0026quot;https://genfanh.github.io/\u0026quot; 7、打包网站到 /docs 文件夹下 hugo -d docs 8、把项目 push 到 github 仓库下 git commit -m \u0026quot;上传hugo\u0026quot; git push origin master 9、查看成果 登录https://genfanh.github.io/查看是否部署成功\n  result \n四、参考资料 使用 Hugo + Github 搭建个人博客 - 知乎 (zhihu.com)\nInstall Hugo | Hugo\n","date":"2020-11-02T15:51:01+08:00","permalink":"https://genfanh.github.io/p/create-hugo-tutorial/","title":"使用 Hugo + Github Page 搭建个人博客"}]