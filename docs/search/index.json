[{"content":"一、题目   题目 \n二、解法 方法：Fisher-Yates 洗牌算法\nFisher-Yates 洗牌算法跟暴力算法很像。在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换 - 这一步模拟了每次从 “帽子” 里面摸一个元素的过程，其中选取下标范围的依据在于每个被摸出的元素都不可能再被摸出来了。此外还有一个需要注意的细节，当前元素是可以和它本身互相交换的 - 否则生成最后的排列组合的概率就不对了。\ntype Solution struct { r *rand.Rand nums []int } func Constructor(nums []int) Solution { return Solution{ r : rand.New(rand.NewSource(time.Now().UnixNano())), nums: nums, } } /** Resets the array to its original configuration and return it. */ func (this *Solution) Reset() []int { return this.nums } /** Returns a random shuffling of the array. */ func (this *Solution) Shuffle() []int { size := len(this.nums) ans := make([]int, size) copy(ans, this.nums) for i:=size; i\u0026gt;1; i-- { index := rand.Intn(i) ans[index], ans[i-1] = ans[i-1], ans[index] } return ans } /** * Your Solution object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.Reset(); * param_2 := obj.Shuffle(); */ 复杂度分析\n  时间复杂度 ： O(n)\nFisher-Yates 洗牌算法时间复杂度是线性的，因为算法中生成随机序列，交换两个元素这两种操作都是常数时间复杂度的。\n  空间复杂度： O(n)\n因为要实现 重置 功能，原始数组必须得保存一份，因此空间复杂度并没有优化。\n  三、参考 转载自： 打乱数组 - 打乱数组 - 力扣（LeetCode） (leetcode-cn.com)\n","date":"2020-11-08T15:32:46+08:00","permalink":"https://genfanh.github.io/p/scramble-array/","title":"384打乱数组"},{"content":"一、题目   题目 \n二、解法 1、方法1：使用额外数组 算法\n我们可以用一个额外的数组来将每个元素放到正确的位置上，也就是原本数组里下标为 $i$ 的我们把它放到 $(i+k)\\% 数组长度$ 的位置。然后把新的数组拷贝到原数组中。\nfunc rotate(nums []int, k int) { size := len(nums) ans := make([]int, size) for i:=0; i\u0026lt;size; i++ { ans[(i+k) % size] = nums[i] } for i:=0; i\u0026lt;size; i++ { nums[i] = ans[i] } } 复杂度分析\n 时间复杂度： O(n) 。将数字放到新的数组中需要一遍遍历，另一边来把新数组的元素拷贝回原数组。 空间复杂度： O(n)。另一个数组需要原数组长度的空间。  2、方法2：使用环状替换 算法\n如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 temp 里面。然后，我们将被替换数字（temp）放到它正确的位置，并继续这个过程 n 次， n 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 $n\\%k==0$，其中 $k=k\\%n$（因为如果 k 大于 n，移动 k 次实际上相当于移动次$k\\%n$）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。\n现在，我们看看上面方法的证明。假设，数组里我们有 n 个元素并且 k 是要求移动的次数。更进一步，假设 $n%k=0$ 。第一轮中，所有移动数字的下标 i 满足 $ i\\%k==0 $ 。这是因为我们每跳 k 步，我们只会到达相距为 k 个位置下标的数。每一轮，我们都会移动 $\\frac{n}{k}$ 个元素。下一轮中，我们会移动满足 $ i\\%k==1 $的位置的数。这样的轮次会一直持续到我们再次遇到 $i\\%k==1$的地方为止，此时 $i=k$。此时在正确位置上的数字共有 $k × \\frac{n}{k} = k$ 个。因此所有数字都在正确位置上。\n让我们看一下接下来的例子，以更好地说明这个过程：\nnums: [1, 2, 3, 4, 5, 6] k: 2   \nfunc rotate(nums []int, k int) { size := len(nums) k = k % size count := 0 for start := 0; count \u0026lt; size; start++ { current := start prev := nums[start] for { next := (current + k) % size prev, nums[next] = nums[next], prev current = next count++ if start == current { break } } } } 复杂度分析\n 时间复杂度：O(n) 。只遍历了每个元素一次。 空间复杂度：O(1) 。使用了常数个额外空间。  3、方法3：使用反转 算法\n这个方法基于这个事实：当我们旋转数组 $k$ 次， $k\\%n$ 个尾部元素会被移动到头部，剩下的元素会被向后移动。\n在这个方法中，我们首先将所有元素反转。然后反转前 $k$ 个元素，再反转后面 $n−k$ 个元素，就能得到想要的结果。\n假设 $n=7$ 且 $k=3$ 。\n原始数组 : 1 2 3 4 5 6 7 反转所有数字后 : 7 6 5 4 3 2 1 反转前 k 个数字后 : 5 6 7 4 3 2 1 反转后 n-k 个数字后 : 5 6 7 1 2 3 4 --\u0026gt; 结果 func rotate(nums []int, k int) { size := len(nums) k %= size r := func(ns []int, start, end int) { for start \u0026lt; end { nums[start], nums[end] = nums[end], nums[start] start++ end-- } } r(nums, 0, size-1) r(nums, 0, k-1) r(nums, k , size-1) } 复杂度分析\n 时间复杂度：O(n) 。 n 个元素被反转了总共 3 次。 空间复杂度：O(1) 。 没有使用额外的空间。  三、参考 转载自：旋转数组 - 旋转数组 - 力扣（LeetCode） (leetcode-cn.com)\n","date":"2020-11-08T14:24:44+08:00","permalink":"https://genfanh.github.io/p/rotate-array/","title":"189旋转数组"},{"content":"一、题目   题目 \n二、解法 动态规划   \n  初始化 dp=[false, ⋯ , false]，长度为 n+1。n 为字符串长度。dp[i] 表示 s 的前 i 位是否可以用 wordDict 中的单词表示。\n  初始化 dp[0]=true，空字符可以被表示。\n  遍历字符串的所有子串，遍历开始索引 i，遍历区间 [0,n)：\n 遍历结束索引 j，遍历区间 [i+1,n+1)：  若 dp[i]=true且 s[i, ⋯ ,j) 在 wordlist 中：dp[j]=true。解释：dp[i]=true 说明 s 的前 i 位可以用 wordDict 表示，则 s[i, ⋯ ,j) 出现在 wordDict 中，说明 s 的前 j 位可以表示。      返回 dp[n]\n  复杂度分析  时间复杂度：O(n^2^) 空间复杂度：O(n)  三、代码 func wordBreak(s string, wordDict []string) bool { size := len(s) m := make(map[string]bool, len(wordDict)) for _, word := range wordDict { m[word] = true } dp := make([]bool, size+1) dp[0] = true for i:=0; i\u0026lt;size; i++ { for j:=i+1; j\u0026lt;=size; j++ { if dp[i] \u0026amp;\u0026amp; m[s[i:j]] { dp[j] = true } } } return dp[size] } 四、参考 转载自：动态规划+记忆化回溯 逐行解释 python3 - 单词拆分 - 力扣（LeetCode） (leetcode-cn.com)\n","date":"2020-11-07T16:03:54+08:00","permalink":"https://genfanh.github.io/p/words-split/","title":"139.单词拆分"},{"content":"一、题目   题目 \n二、解法 动态规划+回溯  动态规划得到了原始输入字符串的任意长度的 前缀子串 是否可以拆分为单词集合中的单词； 我们以示例 2：s = \u0026quot;pineapplepenapple\u0026quot;、wordDict = [\u0026quot;apple\u0026quot;, \u0026quot;pen\u0026quot;, \u0026quot;applepen\u0026quot;, \u0026quot;pine\u0026quot;, \u0026quot;pineapple\u0026quot;] 为例，分析如何得到所有具体解。  所有任意长度的前缀是否可拆分是知道的，那么如果 后缀子串在单词集合中，这个后缀子串就是解的一部分，例如：\n  示例 \n再对比这个问题的输出：\n[ \u0026quot;pine apple pen apple\u0026quot;, \u0026quot;pineapple pen apple\u0026quot;, \u0026quot;pine applepen apple\u0026quot; ] 可以发现，树形结构中，从叶子结点到根结点的路径是符合要求的一个解，与以前做过的回溯算法的问题不一样，这个时候路径变量我们需要在依次在列表的开始位置插入元素，可以使用队列实现。\n三、代码 func wordBreak(s string, wordDict []string) bool { ans := make([]string, 0) size := len(s) // 使用 map 加速查找 \twordMap := make(map[string]bool, size + 1) for _, word := range wordDict { wordMap[word] = true } // 查找是否有解 \tdp := make([]bool, size+1) dp[0] = true for i:=0; i\u0026lt;size; i++ { for j:=i+1; j\u0026lt;=size; j++ { if dp[i] \u0026amp;\u0026amp; wordMap[s[i:j]] { dp[j] = true } } } // 回溯算法，获取所有解 \tpath := make([]string, 0) var backtracking func(start int) backtracking = func(start int) { if start == size \u0026amp;\u0026amp; dp[size] { tmp := strings.Join(path, \u0026#34; \u0026#34;) ans = append(ans, tmp) return } for i := start+1; i\u0026lt;=size; i++ { if dp[start] \u0026amp;\u0026amp; wordMap[s[start:i]] { path = append(path, s[start:i]) backtracking(i) path = path[:len(path)-1] } } } if dp[size] { backtracking(0) } return ans } 四、参考 转载自：动态规划求是否有解、回溯算法求所有具体解（Java） - 单词拆分 II - 力扣（LeetCode） (leetcode-cn.com)\n","date":"2020-11-07T16:03:54+08:00","permalink":"https://genfanh.github.io/p/words-split-ii/","title":"140.单词拆分II"},{"content":"一、题目   题目 \n二、解法 回溯+动态规划优化 搜索问题主要使用回溯法。\n回溯法思考的步骤：\n1、画递归树；\n2、根据自己画的递归树编码。\n思考如何根据这棵递归树编码：\n1、每一个结点表示剩余没有扫描到的字符串，产生分支是截取了剩余字符串的前缀；\n2、产生前缀字符串的时候，判断前缀字符串是否是回文。\n如果前缀字符串是回文，则可以产生分支和结点； 如果前缀字符串不是回文，则不产生分支和结点，这一步是剪枝操作。 3、在叶子结点是空字符串的时候结算，此时从根结点到叶子结点的路径，就是结果集里的一个结果，使用深度优先遍历，记录下所有可能的结果。\n 采用一个路径变量 path 搜索，path 全局使用一个（注意结算的时候，需要生成一个拷贝），因此在递归执行方法结束以后需要回溯，即将递归之前添加进来的元素拿出去； path 的操作只在列表的末端，因此合适的数据结构是栈。  利用「力扣」第 5 题：最长回文子串 的思路，使用空间换时间，利用动态规划把结果先算出来，这样就可以以 O(1) 的时间复杂度直接得到一个子串是否是回文。\n三、代码 func partition(s string) [][]string { ans := make([][]string,0) size := len(s) if size == 0 { return ans } // 预处理 \t// 使用 dp[i][j] 表示 s[i:j] 是否回文 \tdp := make([][]bool, size) for i := range dp { dp[i] = make([]bool, size) } for r:=0; r\u0026lt;size; r++ { for l:=0; l\u0026lt;=r; l++ { if s[l] == s[r] \u0026amp;\u0026amp; (r - l \u0026lt;=2 || dp[l+1][r-1]) { dp[l][r] = true } } } path := make([]string, 0) var backtracking func(start int) backtracking = func (start int) { if start \u0026gt;= size { tmp := make([]string, len(path)) copy(tmp, path) ans = append(ans, tmp) return } for i := start; i \u0026lt; size; i++ { if !dp[start][i] { continue } path = append(path, s[start:i+1]) backtracking(i+1) path = path[:len(path)-1] } } backtracking(0) return ans } 四、参考 转载自：回溯、优化（使用动态规划预处理数组） - 分割回文串 - 力扣（LeetCode） (leetcode-cn.com)\n","date":"2020-11-07T15:15:03+08:00","permalink":"https://genfanh.github.io/p/split-palindrome-string/","title":"131.分割回文串"},{"content":"一、题目   题目 \n二、解法 动态规划 dp[i][j]代表 word1 的前 i 个字符转换成 word2 的前 j 字符需要的最少操作数\n所以，\n当 word1[i] == word2[j] 时， dp[i][j] = dp[i-1][j-1]\n当 word1[i] != word2[j] 时， dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n其中，dp[i-1][j-1] 表示替换操作， dp[i-1][j] 表示删除操作， dp[i][j-1] 表示插入操作。\n注意，针对第一行和第一列需要淡入考虑，如下图所示，引入 '':\n  \n第一行，是 word1 为空时变为 word2 最少要走的步数，也就是插入操作\n第一列，是 word2 为空时 word1 变为 word2 最少要走的步数， 也是删除操作\n最终结果就是 dp[i][j]\n复杂度 时间复杂度： O(m*n)\n空间复杂度： O(m*n)\n三、代码 func minDistance(word1 string, word2 string) int { n, m := len(word1), len(word2) dp := make([][]int, n+1) // word2 为空时 word1 变为 word2 最少要走的步数  for i:=0; i\u0026lt;=n; i++ { dp[i] = make([]int, m+1) dp[i][0] = i } // word1 为空时变为 word2 最少要走的步数  for j:=0; j\u0026lt;=m; j++ { dp[0][j] = j } for i:=1; i\u0026lt;=n; i++ { for j:=1; j\u0026lt;=m;j++ { if word1[i-1] == word2[j-1] { dp[i][j] = dp[i-1][j-1] } else { dp[i][j] = 1 + min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) } } } return dp[n][m] } func min(x, y int) int { if x \u0026lt; y { return x } return y } ","date":"2020-11-05T17:51:36+08:00","permalink":"https://genfanh.github.io/p/edit-distance/","title":"72.编辑距离"},{"content":"一、题目   题目 \n二、解法 动态规划 构造动态方程时，我们认为\n dp[i]为凑成i金额所需要的最少硬币的数值  所以，当所有coins面值硬币选择一个时，其凑成的dp[i-coins[j]]的数值是最小时，可以认为dp[i]最小，动态转化表达式可以有\ndp[i] = min( dp[i-coins[j]] ) + 1 此时最终题解为，\n ans = dp[amount]  复杂度 时间复杂度：O(amount * len(coins) )\n空间复杂度：O(amount)\n三、代码 func coinChange(coins []int, amount int) int { if amount == 0 { return 0 } dp := make([]int, amount+1) // 初始化所有 i\u0026gt;0 的 dp[i] 为 -1  for i := range dp { if i != 0 { dp[i] = -1 } } n := len(coins) for i:=1; i\u0026lt;=amount; i++ { minVal := math.MaxInt64 for j:=0; j\u0026lt;n; j++ { // 若 dp[i-coins[j]] = -1 认为 dp[i-coins[j]] 无解  if i - coins[j] \u0026gt;= 0 \u0026amp;\u0026amp; dp[i-coins[j]] != -1 { minVal = min(minVal, dp[i-coins[j]]) } } // 若minVal没有被赋值， 则认为 dp[i] 无解  if minVal != math.MaxInt64 { dp[i] = minVal + 1 } } return dp[amount] } func min(x, y int) int { if x \u0026lt; y { return x } return y } ","date":"2020-11-05T17:10:50+08:00","permalink":"https://genfanh.github.io/p/coin-change/","title":"322.零钱兑换"},{"content":"一、题目   题目 \n二、解法 动态规划   状态流转图 \n交易k次的状态流转图如上图所示。\n初始状态时，手中没有股票，在初始状态可以保持该动作，不买不卖直至交易结束。\n初始状态只能通过买入进入到买入1状态，当买入1股后，我们可以有以下两种选择：\n 啥也不做，保持买入1股状态，直至若干天后择优卖出 马上手上股票，进入卖出1状态  在卖出1状态时，也有两种选择：\n 啥也不做，保持手上没有股票动作，直至下一个好时机买入 马上进行第二次买入，进入买入2状态  后面的买入2，保持，卖出2直至卖出k后，就无法在进行交易，只能进入交易结束状态\n所以在构造动态规划方程时，使用三个状态变量来表示买卖k次的交易状态\n i表示第i天 k表示已经进行了k次买卖 j表示当前手上是否持有股票  此时我们得到动态规划状态表达式dp[i][k][j]，其中\n dp[i][k][0]表示第i天交易了k次后手上不持有股票的累计最大利润 dp[i][k][1]表示第i天交易了k次后手上持有股票的累计最大利润  此时，我们通过状态转化图，可以有\n# 第i天交易k次后手上不持有股票的累计最大利润为， 1、第i-1天k次后手上不持有股票的累计最大利润，或 2、第i-1天k次交易后手上持有股票的累计最大利润加上第i天卖出股票 ； 1或2中的最大值 dp[i][k][0] = max( dp[i-1][k][0], d[i-1][k][1] + prices[i] ) # 第i天交易k次后手上持有股票的累计最大利润为， 1、第i-1天k次后手上持有股票的累计最大利润，或 2、第i-1天k-1次交易后手上不持有股票的累计最大利润减去第i天买入股票 ； 1或2中的最大值 dp[i][k][1] = max( dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) # 此时题目解为 第i天 0~k 次交易后，手上不持有股票的累计利润最大值 answer = max(dp[i][0~k][0]) 三、代码 func maxProfit(k int, prices []int) int { pLen := len(prices) if len(prices) == 0{ return 0 } //一次交易需要2天，如果交易次数大于总的天数/2，那么可以认为k是无穷大，套框架  if k \u0026gt; pLen/2{ return maxProfit_k_Inf(prices) } tmp := make([][2]int, k+1) dp := make([][][2]int, 0) for i:=0; i\u0026lt;pLen;i++{ dp = append(dp, tmp) } for i:=0; i\u0026lt;pLen; i++{ //base case  if i == 0 { for d:=0; d\u0026lt;=k; d++{ dp[i][d][0]=0 dp[i][d][1]=-prices[i] } continue } for j:=k; j\u0026gt;=1; j--{ dp[i][j][0]=max(dp[i-1][j][0], dp[i-1][j][1]+prices[i]) dp[i][j][1]=max(dp[i-1][j][1], dp[i-1][j-1][0]-prices[i]) } } return dp[pLen-1][k][0] } func maxProfit_k_Inf(prices []int) int { if len(prices) == 0 { return 0 } dp := make([][2]int, len(prices)) /* k = +infinity dp[i][k][0]=max(dp[i-1][k][0], dp[i-1][k][1]+prices[i]) dp[i][k][1]=max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i]) =max(dp[i-1][k][1], dp[i-1][k][0]-prices[i]) 我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) */ for i:=0; i\u0026lt;len(prices); i++{ if i-1 == -1{ dp[i][0]=0 dp[i][1]=-prices[i] continue } dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) } return dp[len(prices)-1][0] } func max(x, y int) int{ if x \u0026gt; y{ return x } return y } ","date":"2020-11-04T20:30:57+08:00","permalink":"https://genfanh.github.io/p/sell-stock/","title":"188.买卖股票的最佳时机"},{"content":"今天主要记录用hugo搭建个人博客的过程，避免下次搭建流程遗失。\n一、安装Hugo 本人使用的是Windows系统，所以选择scoop安装方式。具体步骤如下：\n1、安装scoop 参考 github scoop 网站安装\n2、使用scoop安装hugo 安装hugo拓展版本，因为后续选择主题需要拓展版本，所以安装了此版本\nscoop install hugo-extended 若不喜欢使用拓展版本，可以使用以下指令安装基础版本\nscoop install hugo 3、验证hugo安装 打开CMD，输入hugo version，若版本正确输出则安装成功\n其他平台可参考官网安装教程 Install Hugo\n二、使用hugo创建博客 1、创建网站 在创建前，请进入工作目录\n# 执行创建指令 # 其中 blog 是网站名称，即会在工作目录下创建blog名称文件夹 # 所有网站文件都在blog目录下 hugo new site blog 2、添加hugo主题 hugo有很多第三方开源的主题，可以在官网的themes下自行选择。本人选Stack主题作为博客的主题。\n主题选好后进入blog（也就是刚才创建网站是创建出来的目录）目录下，把stack主题git到themes目录下。\ncd blog git init git submodule add https://github.com/CaiJimmy/hugo-theme-stack.git  注：记得提前安装git\n 3、修改config.toml配置文件 正常流程应该直接修改config.toml文件，但是Stack主题已经内置修改好的文件，直接复制该config.toml到根目录即可\necho 'theme = \u0026quot;hugo-theme-stack\u0026quot;' \u0026gt;\u0026gt; config.toml 4、创建第一篇文章 hugo new posts/HelloWorld.md 5、启动hugo服务器 hugo server -D 三、把Hugo部署到Github Pages上 1、创建一个Github仓库 在github上创建一个仓库，名称一般为\u0026lt;gihub名称\u0026gt;.github.io\n  git_create_repo \n2、把仓库clone到本地 git clone \u0026lt;REPO_URL\u0026gt; 3、创建hugo项目 参照第二步，在仓库目录下创建一个Hugo项目，同时保证hugo项目能在本地运行\nhugo server -D 4、创建新文章 hugo new post/HelloWorld.md 通过指令创建的markdown文章会自动生成如下模板头：\n--- title: \u0026#34;HelloWorld\u0026#34; date: 2020-10-30T21:52:31+08:00 draft: true ---  注：需要把 draft: true 改为 draft: false 才可以上传该篇文章\n 5、修改repo配置 进入刚刚创建的 Repository 的 Setting 界面， 把 GitHub Page 配置下的 Source 配置为Branch:master/docs。这意味着通过URL访问博客时，会从该仓库 master 分支下的 docs 文件夹下读取静态资源。具体如下图所示：\n  repo_settings \n6、修改 config.toml 从第5点得到 GitHub Page 的 URL，把该 URL 替换到 config.toml 配置文件的 baseURL 配置值中\nbaseURL = \u0026quot;https://genfanh.github.io/\u0026quot; 7、打包网站到 /docs 文件夹下 hugo -d docs 8、把项目 push 到 github 仓库下 git commit -m \u0026quot;上传hugo\u0026quot; git push origin master 9、查看成果 登录https://genfanh.github.io/查看是否部署成功\n  result \n四、参考资料 使用 Hugo + Github 搭建个人博客 - 知乎 (zhihu.com)\nInstall Hugo | Hugo\n","date":"2020-11-02T15:51:01+08:00","permalink":"https://genfanh.github.io/p/create-hugo-tutorial/","title":"使用 Hugo + Github Page 搭建个人博客"}]